
##' Function for running a kalman filter to a subset of potential drift dives.
##'
##' This functions is a wrap to a kalman filter implemented in jags (Just another Gibs sampler).
##' It is particularly slow as it will require long chains. Current set up is a burn in of 400.000 iterations.
##' There is a version that can paralelize the chains and take advantage of multicore processors
##' @title Function for applying a Kalman filter to the drift dives
##' @param Data An object of class 'data.frame' that needs to include at least date and drift rate
##' @param update Burn.in length.
##' @param n.iter posterior drawn length.
##' @param n.chains number of chains to be drawn.
##' @param n.adapt adaption length (for jags performance)
##' @param list Logical, if the object is a list or not
##' @return an object of class 'list' that includes: 1) the original dataset (plus some remaping of variables), the model (a jags object), the output etc...
Kalman <- function(Data, update=100000, n.iter=1000, n.chains=3, n.adapt=500, list=FALSE){
    if (list){ Data <- Data[[1]] }
    Data <- Data[order(Data$Date),]
    Data$time <- (as.numeric(Data$Date)-as.numeric(min(Data$Date)))/3600
    requireNamespace('rjags')
    bugs.model <- "
model {
  ## Random walk for mass increments
  delta[1] <- 0
  for(i in 2:N) {
    taudt[i] <- taud/(time[i]-time[i-1])
    delta[i] ~ dnorm(delta[i-1],taudt[i])
  }

  for(i in 1:N) {
    rho[i] <- (m0+delta[i])/(v0+V*delta[i])
    s[i] <- step(rho[i]-1)-step(1-rho[i])
    mu[i] <- a*s[i]*sqrt(abs(rho[i]-1))
    z[i] ~ dbern(p)
    tau[i] <- tau0 + tau1*z[i]
    rate[i] ~ dnorm(mu[i],tau[i])
  }

  ## Halfnormal prior for a
  #a ~ dnorm(-1,100)T(,0)
  a <- -1.2

  taud ~ dgamma(0.001,0.001)

  p ~ dbeta(90000,10000)
}
"
    Data$time <- (as.numeric(Data$Date)-as.numeric(min(Data$Date)))/3600
    model <- rjags::jags.model(textConnection(bugs.model),
                               data = list(
                                   "rate" = Data$NDE,
                                   "time" = Data$time,
                                   "m0" = 100,
                                   "v0" = 90,
                                   "V" = 1.1,
                                   "tau0" = 1,
                                   "tau1" = 10000,
                                   "taud" = 1,
                                   "N" = nrow(Data)),
                               n.chains = n.chains,
                               n.adapt = n.adapt)
    
    
    before <- Sys.time()
    update(model,update)
    after <- Sys.time()
    duration=after-before
    s <- rjags::coda.samples(model,
                             var=c("mu","z"),
                             n.iter=n.iter,thin=10)
    mns <- sapply(s,colMeans)
    
    res <- list(Data = Data, model = model, kalman = s,
                mns = mns, duration = duration, burn.in = update )
    
    ## cat('\n\n\n','time duration : ', duration, '\n\n\n')
    return(res)
    
}






##' function for update objects generated by the local Kalman function
##'
##' Requires an object generated by the local function 'Kalman'. If the object is loaded form a previously saved session, the model will need to be recompiled (and I will have to figure out soon how to do it)
##' @title updateKalman
##' @param data an object generated by the Kalman function
##' @param update number of iterations to be used for update the burn.in.
##' @param n.iter length of the drawn after the last burn.in.
##' @param recompile logical. if TRUE, the model will be recompiled
##' @return an object of class 'kalman'
##' @author Fernando Arce
updateKalman <- function(data,update=100000,n.iter=1000, recompile = FALSE){
    requireNamespace('rjags')
    if (recompile) data$model$recompile() 
    before <- Sys.time()
    update(data$model,update)
    after <- Sys.time()
    data$duration=data$duration + (after-before)
    data$burn.in <- data$burn.in + update
    data$kalman <- rjags::coda.samples(data$model,
                                       var=c("mu","z"),
                                       n.iter=n.iter,thin=10)
    data$mns <- sapply(data$kalman,colMeans)
    return(data)
}

## creo que con 'model'$recompile podria solventarlo


##' Function for post-processing kalman objects
##'
##' This functions extrac the newly generated mu's and zetas and place them into the original Data frame, and return a simple data frame to keep processing
##' @title Kalman post-processing
##' @param Data an object of class 'kalman' generated by the local function Kalman (and or updateKalman)
##' @return an object of class 'data.frame'
##' @author Fernando Arce
PostKalman <- function(Data){
    ## Data must be a list
    output <- Data[[1]]
    values <- rowMeans(Data[[4]])
    params <- length(values)
    output$mus <- values[1:(params/2)]
    output$zetas <- values[(params/2 + 1):params ]
    return(output)
}



##' De esta si que no me acuerdo
##'
##' hablame del mar marinero
##' @title Maximum time?
##' @param seal una puta foca en formato lista
##' @return un numero
##' @author fer
MaxTime <- function(seal){
len <- NULL
for(i in 1:length(seal)){
    fin <- seal[[i]]
    len[[i]] <- max(fin$time)
}
return (max(len))
}



##' Get minimum and maximum days
##'
##' gets mimimum and maximum days
##' @title DayDep
##' @param Data A dataframe
##' @return a data.frame
##' @author Fer Arce
DayDep <- function(Data) { # function for gathering min and max days per deployment
    Data$sec <- as.numeric(Data$Date)
    Data$sec <- Data$sec-min(Data$sec)
    Data$nday <- Data$sec/86400     # nday is the numeric value
    Data$sec <- NULL
    Data$fday <- floor(Data$nday)
    Data$fday <- factor(Data$fday, levels=c(min(Data$fday):max(Data$fday)))
    return(Data)
}

##' metrics del drift rate
##'
##' ufff
##' @title eso 
##' @param test ni idea 
##' @param zetas lol
##' @param zeta.crit el critero
##' @return data frame
##' @author fer
DayDrift <- function(test, zetas=TRUE, zeta.crit=.99){
    if (zetas==TRUE) test <- test[test$zetas >= zeta.crit, ]
    days <- min(floor(test$nday)):max(floor(test$nday))
    media <- rep(NA,length(days))
    mediana <- rep(NA,length(days))
    esede <- rep(NA,length(days))
    driftdays <- unique(floor(test$nday))
    for (i in driftdays){
        daydrifts <- test[floor(test$nday)==i, ]
        media[i] <- mean(daydrifts$NDE,na.rm=TRUE)
        mediana[i] <- median(daydrifts$NDE,na.rm=TRUE)
        esede[i] <- sd(daydrifts$NDE,na.rm=TRUE)
    }
    return(data.frame(av=media,sd=esede, uci= media + esede, lci = media - esede,med=mediana))
}



##' un plot
##'
##' no hase falta disir nada mas
##' @title DayPlot
##' @param tes DataSet
##' @param add Logical value, add if the Day estimated to be added to an existing plot
##' @param col Colour of the lines and points
##' @param points logical, whether points should be plotted or not above the lines
##' @param ... Generic parameters from base::plot function
##' @return a Fucking plot
##' @author Fernando Arce
DayPlot <- function(tes,add=FALSE,col=c('blue','dodgerblue'), points=TRUE,...){
    if (add==FALSE){
        plot(tes[,1],type='l',pch=19, col=col[1],...)
         if (points==TRUE) points(tes[,1],pch=19, col=col[length(col)], cex=.5)
        abline(h=c(-.2,0,.2), col=c('gray','red','gray'))
        ## abline(v=c(10,60,length(tes[,1])), col='gray') #
    } else if (add==TRUE){
        points(tes[,1],type='l',pch=19, ylim=c(-.6,.6), xlim=c(0,250), col=col[1],...)
        if (points==TRUE) points(tes[,1],pch=19, ylim=c(-.5,.4), xlim=c(1,250), col=col[1],...)
    }

}

